using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.IO;
using System.Linq;
using System.Text;
using Humanizer;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace Knapcode.ExplorePackages
{
    [Generator]
    public class CsvRecordGenerator : ISourceGenerator
    {
        private const string Category = "Knapcode.ExplorePackages.SourceGenerator";
        private const string InterfaceName = "ICsvRecord";
        private const string FullInterfaceName = "Knapcode.ExplorePackages." + InterfaceName;

        private static readonly string Template = @"// <auto-generated />
using System;
using System.IO;
using Knapcode.ExplorePackages;

namespace {0}
{{
    /* Kusto DDL:

    .drop table {1};

    .create table {1} (
{2}
    );

    .create table {1} ingestion csv mapping '{1}_mapping'
    '['
{3}
    ']'

    */
    partial class {4}
    {{
        public void Write(TextWriter writer)
        {{
{5}
        }}

        public void Read(Func<string> getNextField)
        {{
{6}
        }}
    }}
}}
";


        public void Initialize(GeneratorInitializationContext context)
        {
            context.RegisterForSyntaxNotifications(() => new SyntaxReceiver());
        }

        public void Execute(GeneratorExecutionContext context)
        {
            if (!(context.SyntaxReceiver is SyntaxReceiver receiver))
            {
                return;
            }

            // System.Diagnostics.Debugger.Launch();

            var type = context.Compilation.GetTypeByMetadataName(FullInterfaceName);
            if (type == null)
            {
                context.ReportDiagnostic(Diagnostic.Create(
                    new DiagnosticDescriptor(
                        id: "EXP0001",
                        title: $"{InterfaceName} interface could not be found",
                        messageFormat: $"The {FullInterfaceName} interface could not be found.",
                        Category,
                        DiagnosticSeverity.Error,
                        isEnabledByDefault: true),
                    Location.None));
            }

            using (var stream = typeof(CsvRecordGenerator)
                .Assembly
                .GetManifestResourceStream($"{typeof(CsvUtility).Namespace}.{nameof(CsvUtility)}.cs"))
            using (var reader = new StreamReader(stream))
            {
                var csvReader = reader.ReadToEnd();
                context.AddSource($"{nameof(CsvUtility)}.cs", SourceText.From(csvReader, Encoding.UTF8));
            }

            foreach (var declaredClass in receiver.CandidateClasses)
            {
                var model = context.Compilation.GetSemanticModel(declaredClass.SyntaxTree);
                var classModel = model.GetDeclaredSymbol(declaredClass);
                var classTypeSymbol = (ITypeSymbol)classModel;
                if (!classTypeSymbol.Interfaces.Contains(type))
                {
                    continue;
                }

                if (!declaredClass.Modifiers.Any(x => x.IsKind(SyntaxKind.PartialKeyword)))
                {
                    context.ReportDiagnostic(Diagnostic.Create(
                        new DiagnosticDescriptor(
                            id: "EXP0002",
                            title: $"{InterfaceName} implementor is not partial",
                            messageFormat: $"The class {{0}} implements {InterfaceName} but is not declared as partial.",
                            Category,
                            DiagnosticSeverity.Error,
                            isEnabledByDefault: true),
                        Location.Create(declaredClass.SyntaxTree, declaredClass.Span),
                        declaredClass.Identifier.Text));
                    continue;
                }

                var classNamespacePrefix = classModel.ContainingNamespace.ToString() + ".";

                var kustoTableBuilder = new KustoTableBuilder(indent: 8);
                var kustoMappingBuilder = new KustoMappingBuilder(8);
                var writerBuilder = new WriteBuilder(indent: 12);
                var readerBuilder = new ReadBuilder(indent: 12);

                var visitors = new IPropertyVisitor[]
                {
                    kustoTableBuilder,
                    kustoMappingBuilder,
                    writerBuilder,
                    readerBuilder,
                };

                var sortedProperties = new List<IPropertySymbol>();
                var currentType = classModel;
                while (currentType != null)
                {
                    sortedProperties.AddRange(currentType
                        .GetMembers()
                        .OfType<IPropertySymbol>()
                        .OrderByDescending(x => x.Locations.First().SourceSpan.Start));
                    currentType = currentType.BaseType;
                }

                sortedProperties.Reverse();
                var propertyNames = sortedProperties.Select(x => x.Name).ToImmutableHashSet();

                foreach (var propertySymbol in sortedProperties)
                {
                    var propType = propertySymbol.Type.ToString();
                    var propName = propertySymbol.Name;

                    var prettyType = PropertyHelper.GetPrettyType(classNamespacePrefix, propertyNames, propertySymbol);
                    foreach (var visitor in visitors)
                    {
                        visitor.OnProperty(propertySymbol, prettyType);
                    }
                }

                foreach (var visitor in visitors)
                {
                    visitor.Finish();
                }

                var className = declaredClass.Identifier.Text;
                var kustoTableName = "Jver" + className.Pluralize();

                context.AddSource(
                    $"{className}.{InterfaceName}.cs",
                    SourceText.From(
                        string.Format(
                            Template,
                            classModel.ContainingNamespace,
                            kustoTableName,
                            kustoTableBuilder.GetResult(),
                            kustoMappingBuilder.GetResult(),
                            className,
                            writerBuilder.GetResult(),
                            readerBuilder.GetResult()),
                        Encoding.UTF8)); ;
            }
        }

        private class SyntaxReceiver : ISyntaxReceiver
        {
            public List<ClassDeclarationSyntax> CandidateClasses { get; } = new List<ClassDeclarationSyntax>();

            public void OnVisitSyntaxNode(SyntaxNode syntaxNode)
            {
                if (!(syntaxNode is ClassDeclarationSyntax classDeclarationSyntax))
                {
                    return;
                }

                var hasInterface = classDeclarationSyntax
                    .BaseList?
                    .Types
                    .Select(x => x.Type)
                    .OfType<IdentifierNameSyntax>()
                    .Select(x => x.Identifier.Text)
                    .Any(x => x.IndexOf(InterfaceName, StringComparison.OrdinalIgnoreCase) > -1);

                if (hasInterface == true)
                {
                    CandidateClasses.Add(classDeclarationSyntax);
                }
            }
        }
    }
}
