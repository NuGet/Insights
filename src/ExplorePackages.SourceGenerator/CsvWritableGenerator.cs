using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace Knapcode.ExplorePackages
{
    [Generator]
    public class CsvWritableGenerator : ISourceGenerator
    {
        private const string Category = "Knapcode.ExplorePackages.SourceGenerator";
        private const string InterfaceName = "Knapcode.ExplorePackages.ICsvWritable";

        private static readonly string Template = @"// <auto-generated />
using System.IO;
using Knapcode.ExplorePackages;

namespace {0}
{{
    partial class {1}
    {{
        public void Write(TextWriter writer)
        {{
{2}
        }}
    }}
}}
";


        public void Initialize(GeneratorInitializationContext context)
        {
            context.RegisterForSyntaxNotifications(() => new SyntaxReceiver());
        }

        public void Execute(GeneratorExecutionContext context)
        {
            if (!(context.SyntaxReceiver is SyntaxReceiver receiver))
            {
                return;
            }

            // System.Diagnostics.Debugger.Launch();

            var csvWritableType = context.Compilation.GetTypeByMetadataName(InterfaceName);
            if (csvWritableType == null)
            {
                context.ReportDiagnostic(Diagnostic.Create(
                    new DiagnosticDescriptor(
                        id: "EXP0001",
                        title: "ICsvWritable interface could not be found",
                        messageFormat: $"The {InterfaceName} interface could not be found.",
                        Category,
                        DiagnosticSeverity.Error,
                        isEnabledByDefault: true),
                    Location.None));
            }

            foreach (var declaredClass in receiver.CandidateClasses)
            {
                var model = context.Compilation.GetSemanticModel(declaredClass.SyntaxTree);
                var classModel = model.GetDeclaredSymbol(declaredClass);
                var classTypeSymbol = (ITypeSymbol)classModel;
                if (!classTypeSymbol.Interfaces.Contains(csvWritableType))
                {
                    continue;
                }

                if (!declaredClass.Modifiers.Any(x => x.IsKind(SyntaxKind.PartialKeyword)))
                {
                    context.ReportDiagnostic(Diagnostic.Create(
                        new DiagnosticDescriptor(
                            id: "EXP0002",
                            title: "ICsvWritable implementor is not partial",
                            messageFormat: "The class {0} implements ICsvWritable but is not declared as partial.",
                            Category,
                            DiagnosticSeverity.Error,
                            isEnabledByDefault: true),
                        Location.Create(declaredClass.SyntaxTree, declaredClass.Span),
                        declaredClass.Identifier.Text));
                    continue;
                }

                var stringBuilder = new StringBuilder();
                const int indent = 12;

                var sortedMembers = declaredClass.Members.OrderBy(x => x.SpanStart);
                foreach (var member in sortedMembers)
                {
                    var memberSymbol = model.GetDeclaredSymbol(member);
                    if (memberSymbol is IPropertySymbol propertySymbol)
                    {
                        if (stringBuilder.Length > 0)
                        {
                            stringBuilder.AppendLine();
                            stringBuilder.Append(' ', indent);
                            stringBuilder.AppendLine("writer.Write(',');");
                        }

                        var type = propertySymbol.Type.ToString();
                        var name = propertySymbol.Name;

                        stringBuilder.Append(' ', indent);
                        switch (type)
                        {
                            case "bool":
                            case "bool?":
                            case "short":
                            case "short?":
                            case "ushort":
                            case "ushort?":
                            case "int":
                            case "int?":
                            case "uint":
                            case "uint?":
                            case "long":
                            case "long?":
                            case "ulong":
                            case "ulong?":
                            case "System.Guid":
                            case "System.Guid?":
                            case "System.TimeSpan":
                            case "System.TimeSpan?":
                                stringBuilder.AppendFormat("writer.Write({0});", name);
                                break;
                            case "string":
                                stringBuilder.AppendFormat("CsvUtility.WriteWithQuotes(writer, {0});", name);
                                break;
                            case "System.DateTimeOffset":
                                stringBuilder.AppendFormat("writer.Write({0}.ToString(\"O\"));", name);
                                break;
                            case "System.DateTimeOffset?":
                                stringBuilder.AppendFormat("writer.Write({0}?.ToString(\"O\"));", name);
                                break;
                            default:
                                stringBuilder.AppendFormat("CsvUtility.WriteWithQuotes(writer, {0}?.ToString());", name);
                                break;
                        }
                    }
                }

                stringBuilder.AppendLine();
                stringBuilder.Append(' ', indent);
                stringBuilder.Append("writer.WriteLine();");

                var className = declaredClass.Identifier.Text;
                context.AddSource(
                    $"{className}.CsvWritable.cs",
                    SourceText.From(
                        string.Format(
                            Template,
                            classModel.ContainingNamespace,
                            className,
                            stringBuilder),
                        Encoding.UTF8));
            }
        }

        private class SyntaxReceiver : ISyntaxReceiver
        {
            public List<ClassDeclarationSyntax> CandidateClasses { get; } = new List<ClassDeclarationSyntax>();

            public void OnVisitSyntaxNode(SyntaxNode syntaxNode)
            {
                if (!(syntaxNode is ClassDeclarationSyntax classDeclarationSyntax))
                {
                    return;
                }

                var hasInterface = classDeclarationSyntax
                    .BaseList?
                    .Types
                    .Select(x => x.Type)
                    .OfType<IdentifierNameSyntax>()
                    .Select(x => x.Identifier.Text)
                    .Any(x => x.IndexOf("ICsvWritable", StringComparison.OrdinalIgnoreCase) > -1);

                if (hasInterface == true)
                {
                    CandidateClasses.Add(classDeclarationSyntax);
                }
            }
        }
    }
}
